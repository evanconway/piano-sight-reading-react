18th of May, 2023

Moving this app over to react/redux is not as drag and drop as I thought it'd be. Further more I'm pretty sure there's some crappy logic in the old design that I'd like to improve. So it's time to bust out a txt file to help organize thoughts and plan things out.

Let's start by describing how the old app worked as best we can. The key part is that the "music" is an array of chord objects, which store midi values for notes. The number of entries in the array is equal to the greatest number of notes per measure between the staffs (top and bottom) times the number of measures. So for example if there were 9 measures and the bottom staff was quarters notes and the top staff half notes, then the total number of entries in the array would be 36 (9 measures x 4 notes per measure bottom staff). A cursor keeps track of which index in the array the user is playing. Using navigator.requestMidiAccess, we can setup callbacks when the user plays a midi device. If a midi event contains the same values as the chord at the current index, then the cursor advances.

In addition to re-writing the above logic, we have to create random music generation in a logical way. We have to render the music to the DOM using abcjs, which requires a special string. Here's an example of a string generated by the old system:

T:
M:4/4
L:1/48
K:C
%%staves {1 2}
V:1
[K:C clef=treble]
[CC']12 D'12 D12 A12 |F'12 F'12 D12 F'12 |G12 F12 C'12 C'12 |F'12 G'12 C'12 G'12 |
V:2
[K:C clef=bass]
E,24 C24 |A,,24 C24 |F,24 F,24 |C24 C24 |
V:1
[K:C clef=treble]
D12 G'12 F'12 G'12 |C'12 F'12 D12 [CEF]12 |[CBC']12 F12 A12 [CGB]12 |C'12 E'12 D12 F12 |
V:2
[K:C clef=bass]
A,24 B,,24 |G,24 E,24 |C,24 A,24 |C,24 F,,24 |
V:1
[K:C clef=treble]
F12 E'12 F12 F'12 |D'12 G'12 E12 E12 |D12 E'12 F'12 D'12 |F'12 E'12 F12 B12 |
V:2
[K:C clef=bass]
G,24 A,,24 |C,24 A,24 |E,24 F,24 |C24 F,,24 |
V:1
[K:C clef=treble]
G12 D'12 E12 D12 |G'12 G12 G'12 A12 |F12 F'12 [CBC']12 E12 |D'12 E12 F'12 [CC']12 |
V:2
[K:C clef=bass]
B,,24 C24 |G,24 B,24 |A,,24 G,,24 |F,,24 E,24 |
V:1
[K:C clef=treble]
C'12 [CEA]12 C'12 A12 |B12 G'12 C'12 F'12 |B12 C'12 G'12 B12 |E'12 D12 G'12 B12 |]
V:2
[K:C clef=bass]
B,24 C,24 |F,,24 E,24 |A,24 A,24 |E,24 B,,24 |]

The above is ABC notation. We'll have to explore this site more later to make sure we understand what we're doing: https://abcnotation.com/

The main takeaway here is that we have to understand which notes are in the top staff, and which are in the bottom, in order to generate the above notation. So we can't simply generate the array we described above then derive the notation from that.

Unless perhaps we modify our chord object to keep track of which midi values are in the top staff, and which are in the bottom? This could work because we keep track of what duration the top/bottom staff notes should be in global state. We could simply grab all top/bottom staff notes from the array, then add notes to the generate string above with the currect duration.

However now I'm thinking about how precise this system should be. Does it make sense to create a data set that could represent any piece of music, even those without consistent durations? I like that idea because it lets us more easily expand this app in the future. Maybe users could create custom pieces of music to play through?

The first thing that throws me off about doing that is keeping track of when key or time signature changes. Our system would have to go measure by measure, and each measure would need its own time signature, key signature, set of bottom notes, and set of top notes. Additionally each note would have to keep track of its own duration. Now that I've described it to myself, I'm not against doing this because it sounds manageable. And I like the idea of our custom data containing so much information about the music by itself. I can imagine making a system that randomly generates this data, or allowing the user to create their own custom data.

Then, given this, I saw we proceed with making this custom music data, a way to track it in state, and a system of rendering it with abcjs. We could easily create dummy data that's just a bunch of quarter notes of the same note. Later we'll worry about creating logic to randomly generate it.

Quick note, I don't think using the entity adapter makes sense for most of this app. We don't have lot's of pieces of data that will be individuall updated, added, or removed.



31st of May, 2023

Need to get head on straight after the break. Last time we were considering how to store the music data. Since we committed to keeping track of changes in time/key signature, we'll have to store things measure by measure. I think we have a pretty straightforward strategy for storing data. Each measure will have 2 arrays of chords objects, one for bottom staff and one for top. It will also store the key and time signature of the measure.

The chords I'm a bit stumped by because I want to allow for correct accidentals. This means we can't only store the midi values of notes in the chords. We have to store the exact scale degree and any accidentals on it. But when it comes time to determine the exact midi value of a note, we'll need the key signature as well as the scale degree to find it. So, at least for now, we'll store pitch data as just scale degree, register, and accidental. 

Given this, a chord will be an array of pitch ojbects. The chord will also store duration, and we'll have a flag to determine if it's a rest or not. Or perhaps we should use an empty pitch array to signify the chord is a rest? Not sure, we'll worry about that later. I think I've got what I need to progress:

music state is an array of measures
measures store time/key signature and array of top and bottom staff chords
chords store duration and array of pitches
pitches store scale degree, register, and accidentals

Ah, but I want to think a little bit more about how we're handling duration. Since we want a cursor to be able to essentially "iterate" over the notes, we need a way to connect the duration of the top staff notes to the bottom. In our old system we simply set a "resolution" for each measure. I think it was 192 because it accomodated many divisions of 4 and 3. This way we could be sure the same number referenced the same spot in both the top and bottom staff array. And there would be empty spots in the array after each note to indicate its duration. Although that system would work here, I dislike it because it doesn't accomodate all possible rhythm combinations, and it feels ugly to have two different concepts represent duration of a note.

Ugh, ya know what let's just do that for now. I can't think of a better system atm, and honestly we'll probably never revisit this since it's more of a portfolio piece. Let's say eigth notes have a value of 12 (since that should cover most common values), which gives quarters a value of 24, and regular 4/4 measures a whole value of 96. We'll adjust these values if I find something wrong. 

I'm realizing I'm not exactly sure how to handle random pitch selection. We need a way to cap what pitches we select from. But since our pitch object works using scale degree, we can't use a pitch object since that changes based on the chosen key signature. I think we need to instead store a pitch class and register for capping random selection.


1st of June, 2023

Still thinking on how to handle random pitch generation. We created a separate type to represent a pitch cap since it's a slightly different idea than a pitch within a key signature. The pitch cap is just a register and class, where as an actual pitch is a scale degree and register. I have an idea of creating an array of possible pitches given a scale degree, then removing ones that don't fit within the given caps. The trick with this is determining if a pitch is above/below a cap. I'm willing to bet we can worry about that logic later.

At the moment I'm actually distracted by displaying this data. Let's add the start of the random music generation logic just as comments, then focus on making the music displayable using dummy data.

I have a new idea about caps for pitches, let's just use an actual pitch. Originally I wanted to keep the idea of caps and pitches separate so that users could choose a spot on the staff as their cap, instead of a specific pitch from the key. Otherwise I'd probably have to repopulate the cap list with pitches from the key evertime the user changed keys. Except I just realized that's not hard at all, and in-fact I think that's a clearer and better way to do it!


2nd of June, 2023

I've realized I haven't thought out how I'm going to determine number of measures per line, or how we'll iterate over them to determine what the actual sheet music looks like.


5th of June, 2023

I was going to write out how I was going to generate the abc string, but I managed to write some code anyway.


6th of June, 2023

Last time we were working on finishing the abc js string creation. And to do that we decided to make a hard coded mapping of key signatures, scale degress, midi values and pitch classes. This way we also have easy access to the pitch class of a given pitch (which we need for notation). When we last looked at this we realized we needed to create each line staff by staff because of how abc notation works. We'll with our strategy from yesterday.

We just added a small function to convert a pitch to an abc pitch. However it's not finished because it doesn't account for accidentals. That could be annoying since we'll have to determine the "natural" accidental on the pitch based on the key, and determine if we should use a natural/flat/sharp to adjust it based on that. But for now let's just see if this function works well enough to keep moving forward.

Turns out we had some flaws in our logic for determining how many measures should be on 1 line. Firstly, I realized it won't actually be that hard to make a function with returns the width of a given measure. We'll have to use some magic numbers for this, but given that music notes are fixed size things regardless of screen size I think this is fine.

Ah, a self note about some logic that I couldn't wrap my head around before. We use the width of the page and the width of measures to determine how many measures there are per line. But we never calculate how many lines there are. Instead we use the height of the page, and the probable width of measures to determine how many measures there should be.


8th of June, 2023

We managed to fix our random music generation, abc string generation, and managed to map the html elements drawing the notes to our music data. However I forgot that you can't store complex objects like HTMLElements in redux. So we need to redo this so it uses something serializable. My first idea is to store some sort of string we can query later to get the correct element when needed. I wonder if we can give the notes created by abcjs individaul ids. If so that would be ideal.

Using id strings to refer to the html elements would be perfect because then we could create these ids during music creation, and assign them to the paths during render. This means our created music data would not need to be mutated, or a new version with correct path mappings created.

As I'm writing out the logic for advance/retreating the music cursor, I'm realizing I'm not sure we ever needed to split out the bottom and top staff chords into separate arrays. This is something worth revisiting later. I think I had a good reason but I don't remember what it was.


11th of June, 2023

We made significant progress without needing to plan much. Now it correctly generates random music in C-major, there is a cursor which can be advanced/retreated, and playing the piano will trigger midi events which will advance the cursor. However right now we have an issue where the hook that checks for correct play is triggering on loop forever on the final chord. Additionally it appears to fire 3 times when the correct chord is played:

1: final note of correct chord is played
2: fires again for new target chord appearing because advanceCursor triggers updated musicCurrentMidi value
3. fires again for new playedMidi value

It appears the redux state and local react state don't update synchronously. Either way I think having this logic here is not react-idiomatic. So I'm going to try rigging everything in the midi handler instead.

That fixed it. I'm guessing what was happening is that advancing the cursor, even if it didn't actually change the values, still changed the actual object selected by the selector, which updates the value musicCurrentMidi. And since hooks appear to trigger with the data they have, regardless of what it will eventually become, that meant that even though we had called setPlayedMidi([]), that same hook would still re-trigger for the updated musicCurrentMidi value with the old playedMidi value. So we would continuously trigger dispatch(advanceCursor) wich continuously created new musicCurrentMidi values which continuously re-triggered the hook.

14th of June, 2023

It's been a few days. Time to plan out the next feature. It should be music customizability, or user preferences. Our random music generation logic should theoretically work for all


15th of June, 2023

Going to work on making sure the score resizes correctly. In a way, user preferences are probably more important, but the lack of responsiveness is driving me crazy.

We've encountered an interesting bug. When the scale of the abcjs render is set to anything less than one, the the music doesn't resize with the window. On resize, our logic is setup to get the width of the div the score should be rendered to, and passes it to our abcjsRender function. This works as expected with scale sizes of 1 or great. But when less than one the width of the div remains the same. It sticks the value it had when the page loaded. Why would this be happening? Is the abcjsRender somehow affecting the parent div when invoked with a scale less than 1?

I think I've figured out the cause. The abcjs.render() function applies a width style to the target element when the scale is less than 1. Then, when resizing, since the div already has a width from the style, it never resizes based on the window size like normal. So it's just stuck.

style with scale greater than or equal to 0:

    background-color: rgb(255, 224, 179);
    max-width: 1100px;
    border-radius: 8px;
    overflow: hidden;
    height: 891.77px;

style with scale less than 0:

    background-color: rgb(255, 224, 179);
    max-width: 1100px;
    border-radius: 8px;
    overflow: hidden;
    width: 936px;
    height: 891.77px;

It looks like we've managed to fix this by adding some logic that, after invoking abcjs.render(), sets the style attribute of the score div with the width property parsed out.


15th of July, 2023

Been out of it for a while, but made some decent progress in the last week. Right now working on making sure min and max pitch values can be selected as user options. Originally I allowed the user to select the pitch itself relative to the key signature. But I've just realized this doesn't work well. For example if we're in the key of C and I set scale degree 5 register 5 as the highest possible pitch, that's the G above the staff in the treble clef, but if we change the key to F that's suddenly the C on the 3rd space of the treble clef. I think that instead the caps should reflext the lines/spaces on the staff. We'll have to work out a different system that's more intuitive.


17th of July, 2023

So, we could store pitch caps for random note selection as pitch class and register. When displaying these to the user we could add flats/sharps based on the key signature. When the user selects a note as a pitch cap, we'll simply find the pitch in the key with the same register and pitch class and set that pitch as the cap. We may need to create the pitch cap as a model and functions to translate caps to pitches given a key.

The logic currently breaks now when changing keys. I believe it has something to our pitch cap system restricting the pitches that can be chosen too aggresively, which forces undefined pitches into the music.


18th of July, 2023

Looks like we got random music generation fixed, and correctly updating with key changes, but it looks like minor keys are bugged. Note detection does not occur. Also when the music regenerates the cursor is not reset to the starting position.

Turns out we had just entered our data for minor keys incorrectly. Next we should look at the bug where differing durations in top and bottom staff don't advance cursor correctly.

We've discovered that the L: setting of ABC notation doesn't work the way we thought it did. Turns out that is a universal value that doesn't change relative to the time signature. So we should probably set that to be 96 at all times (or whatever value we decide to go with in the end). 


19th of July, 2023

Now that we've added selectors for most options in the random music generation, it's time to asses what we've done and figure out what's left to do. Major features we still need are:

1. Harmony generation
2. Music generates perfect number of measures based on screen size
3. Options menu must be responsive
4. Must figure out correct access to options menu for phone, tablet, and desktop sizes

Of those, I think I'd like to work on correct measure numbers next. Numbers 3 and 4 are kind of part fo the same goal. And truthfully the harmony generation should probably be more of a stretch goal.


21st of July, 2023

Having trouble with our number of measure calculations. We are sowly making something that works but it does not feel solid or idiomatic for web design. I also noticed a bug where the number of measures changes drastically when resizing at certain points. And these points are my phone and tablet sizes minus 20 pixels (800px and 500px respectively). We'll need to review my responsive code to figure out why this is happening.

Encoutered a bug clicking on a note highlighted a different note.


22nd of July, 2023

It seems like we were able to add a slightly better resize system. It uses the dimensions of the window to set the size of the score. After the size of the score is set we determine the number of measures to add to the music and generate it. After the music is generated we render it to the score element with abcjs, and then force the dimensions of the score element to be the same as before after abcjs has changed it.


30th of December, 2023

Making a note that we should look into possibly specifying the number of measures per line in the random music generation logic. Simply trying to get the right layout by specifying the number of measures don't seem to work well.


9th of February, 2024

Finally got back to working on this. I started changing over the entire music storage and rendering system to be a 2D array so that we store music line by line, and render line by line. However I'm doubting this approach. We originally didn't want to do this so that if we ever had non-randomly generated music (maybe user created files?), we could allow the rendering system to take care of it automatically. I suppose we could store the randomly generated music line by line, but it feels awkward. Unfortuantely I think I should rip out the work I just did. Go back to music simply being an array of measures, but also add numOfLines and measuresPerLine variables to our abc rendering function. This way music could be display more automatically, but we have strict control if we need it.

Actually, did the rendering function ever automatically line split? Maybe it did, but it didn't work very well.


10th of February, 2024

I just realized something about the current rendering system, and how I'm being silly agonizing over accomodating measures per line or not. If we do ever add custom music, we're going to need some sort of pagination system. The current system isn't even close to accounting for that. It's laser focused on just rendering a single page. In fact the rendering function assumes the music it's given is a single page. Since randomly generate music will always have a very consisten number of measures per line, and lines per page, we should just make the whole system work around this. And when it comes time to do something completely different, we'll worry about it then.

We may have finally fixed the line rendering issue. Determining measures per line seems to work much better as something determined on resize and not on render. Honestly the old way was never good because we were making the same calculation twice. Now we have to solve the bug where the last line doesn't stretch to the width of the page.

I have an observation about abcjs and changing the size of rendered music. In the existing websites I've found online, when the page is resized the entire score is resized like an image. It retains its aspect ratio and is simply scaled to the largest size it can fit. It certainly doesn't do anything like change line breaks or whatever. I wonder if this is how we should be implementing our system. Perhaps abcjs is rigged to work a certain way and trying to fight against this is a lost cause. Let's explore this first before trying to fix our specific last line bug.

I have a theory. I wonder if mutating the score div, after it's rendered, is the source of our bug. The reason we do this is because we're using the dimensions of the div to determine how much music we render to it. But since the abcjs render mutates the dimensions of this div we're forced to mutate it back to its original dimensions before the render, otherwise it creates an endless render loop (we rerender abcjs when the score div changes size). Let's see if we can try determining music dimensions and values based on the window size instead. The abcjs will never be able to mutate these. We'll also try removing all styles from the score div so that abcjs will have total control over how it renders.


11th of February, 2024

Alas... our impatience and inability to just sit down and read docs has cost us loads of time and stress. Turns out the abc standard keeps the last line small on purpose. There's a simple directive `%%stretchlast` which forces the last line to stretch to the width of the music page. There's also a `%%barsperstaff x` directive which forces line breaks every every x bars. This would've solved our line break issue ages ago. With these tools, we could go back to storing music as a 1D array, which I think is more elegant. We also wouldn't need to do a complex system for line breaks on render.

There are some directives in the abc manual I want to experiment with, notably:

%%pageheight       <length>
%%pagewidth        <length>

Currently we're mutating the dom after abcjs does its rendering to ensure our score div has the correct dimensions. But if these page directives let us ensure abcjs makes the div be an exact size, well then we don't need to do those mutations. Need to experiment though.

Since we have another excuse to go through the entire music system again, I think we should change how chords are stored. Instead of having two staff arrays per measure (one for top and one for bottom) and ensuring they're the same size, let's create a staff object, and each measure is an array of these staff objects each of which have a top and bottom chord.

We managed to redo how music is stored, and add the %%barsperline directive to the abc notation. We were also able to tidy up some of the styling and code. Now we should look into the page directives and bugs. I just realized that trying to play with 4 notes per staff in C minor does not work properly. Perhaps this is a good opportunity to introduce real tests to the code.

We've introduced real tests, fixed some bugs, and tidied the code even more. Unfortuantely I also did some exploring of the page dimension directives and they don't appear to work at all. Very frustrating. However, our system is working as intended right now. I think we should do some reflecting later and determine what features we should add next. For starters I know we don't have harmony, but I'm sure there's a lot more we could do.
